// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"shorterurl/user/rpc/internal/dal/model"
)

func newTLinkLocaleStat(db *gorm.DB, opts ...gen.DOOption) tLinkLocaleStat {
	_tLinkLocaleStat := tLinkLocaleStat{}

	_tLinkLocaleStat.tLinkLocaleStatDo.UseDB(db, opts...)
	_tLinkLocaleStat.tLinkLocaleStatDo.UseModel(&model.TLinkLocaleStat{})

	tableName := _tLinkLocaleStat.tLinkLocaleStatDo.TableName()
	_tLinkLocaleStat.ALL = field.NewAsterisk(tableName)
	_tLinkLocaleStat.ID = field.NewInt64(tableName, "id")
	_tLinkLocaleStat.FullShortURL = field.NewString(tableName, "full_short_url")
	_tLinkLocaleStat.Date = field.NewTime(tableName, "date")
	_tLinkLocaleStat.Cnt = field.NewInt32(tableName, "cnt")
	_tLinkLocaleStat.Province = field.NewString(tableName, "province")
	_tLinkLocaleStat.City = field.NewString(tableName, "city")
	_tLinkLocaleStat.Adcode = field.NewString(tableName, "adcode")
	_tLinkLocaleStat.Country = field.NewString(tableName, "country")
	_tLinkLocaleStat.CreateTime = field.NewTime(tableName, "create_time")
	_tLinkLocaleStat.UpdateTime = field.NewTime(tableName, "update_time")
	_tLinkLocaleStat.DelFlag = field.NewBool(tableName, "del_flag")

	_tLinkLocaleStat.fillFieldMap()

	return _tLinkLocaleStat
}

type tLinkLocaleStat struct {
	tLinkLocaleStatDo

	ALL          field.Asterisk
	ID           field.Int64  // ID
	FullShortURL field.String // 完整短链接
	Date         field.Time   // 日期
	Cnt          field.Int32  // 访问量
	Province     field.String // 省份名称
	City         field.String // 市名称
	Adcode       field.String // 城市编码
	Country      field.String // 国家标识
	CreateTime   field.Time   // 创建时间
	UpdateTime   field.Time   // 修改时间
	DelFlag      field.Bool   // 删除标识 0：未删除 1：已删除

	fieldMap map[string]field.Expr
}

func (t tLinkLocaleStat) Table(newTableName string) *tLinkLocaleStat {
	t.tLinkLocaleStatDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tLinkLocaleStat) As(alias string) *tLinkLocaleStat {
	t.tLinkLocaleStatDo.DO = *(t.tLinkLocaleStatDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tLinkLocaleStat) updateTableName(table string) *tLinkLocaleStat {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewInt64(table, "id")
	t.FullShortURL = field.NewString(table, "full_short_url")
	t.Date = field.NewTime(table, "date")
	t.Cnt = field.NewInt32(table, "cnt")
	t.Province = field.NewString(table, "province")
	t.City = field.NewString(table, "city")
	t.Adcode = field.NewString(table, "adcode")
	t.Country = field.NewString(table, "country")
	t.CreateTime = field.NewTime(table, "create_time")
	t.UpdateTime = field.NewTime(table, "update_time")
	t.DelFlag = field.NewBool(table, "del_flag")

	t.fillFieldMap()

	return t
}

func (t *tLinkLocaleStat) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tLinkLocaleStat) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 11)
	t.fieldMap["id"] = t.ID
	t.fieldMap["full_short_url"] = t.FullShortURL
	t.fieldMap["date"] = t.Date
	t.fieldMap["cnt"] = t.Cnt
	t.fieldMap["province"] = t.Province
	t.fieldMap["city"] = t.City
	t.fieldMap["adcode"] = t.Adcode
	t.fieldMap["country"] = t.Country
	t.fieldMap["create_time"] = t.CreateTime
	t.fieldMap["update_time"] = t.UpdateTime
	t.fieldMap["del_flag"] = t.DelFlag
}

func (t tLinkLocaleStat) clone(db *gorm.DB) tLinkLocaleStat {
	t.tLinkLocaleStatDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t tLinkLocaleStat) replaceDB(db *gorm.DB) tLinkLocaleStat {
	t.tLinkLocaleStatDo.ReplaceDB(db)
	return t
}

type tLinkLocaleStatDo struct{ gen.DO }

type ITLinkLocaleStatDo interface {
	gen.SubQuery
	Debug() ITLinkLocaleStatDo
	WithContext(ctx context.Context) ITLinkLocaleStatDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITLinkLocaleStatDo
	WriteDB() ITLinkLocaleStatDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITLinkLocaleStatDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITLinkLocaleStatDo
	Not(conds ...gen.Condition) ITLinkLocaleStatDo
	Or(conds ...gen.Condition) ITLinkLocaleStatDo
	Select(conds ...field.Expr) ITLinkLocaleStatDo
	Where(conds ...gen.Condition) ITLinkLocaleStatDo
	Order(conds ...field.Expr) ITLinkLocaleStatDo
	Distinct(cols ...field.Expr) ITLinkLocaleStatDo
	Omit(cols ...field.Expr) ITLinkLocaleStatDo
	Join(table schema.Tabler, on ...field.Expr) ITLinkLocaleStatDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITLinkLocaleStatDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITLinkLocaleStatDo
	Group(cols ...field.Expr) ITLinkLocaleStatDo
	Having(conds ...gen.Condition) ITLinkLocaleStatDo
	Limit(limit int) ITLinkLocaleStatDo
	Offset(offset int) ITLinkLocaleStatDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITLinkLocaleStatDo
	Unscoped() ITLinkLocaleStatDo
	Create(values ...*model.TLinkLocaleStat) error
	CreateInBatches(values []*model.TLinkLocaleStat, batchSize int) error
	Save(values ...*model.TLinkLocaleStat) error
	First() (*model.TLinkLocaleStat, error)
	Take() (*model.TLinkLocaleStat, error)
	Last() (*model.TLinkLocaleStat, error)
	Find() ([]*model.TLinkLocaleStat, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TLinkLocaleStat, err error)
	FindInBatches(result *[]*model.TLinkLocaleStat, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TLinkLocaleStat) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITLinkLocaleStatDo
	Assign(attrs ...field.AssignExpr) ITLinkLocaleStatDo
	Joins(fields ...field.RelationField) ITLinkLocaleStatDo
	Preload(fields ...field.RelationField) ITLinkLocaleStatDo
	FirstOrInit() (*model.TLinkLocaleStat, error)
	FirstOrCreate() (*model.TLinkLocaleStat, error)
	FindByPage(offset int, limit int) (result []*model.TLinkLocaleStat, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITLinkLocaleStatDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t tLinkLocaleStatDo) Debug() ITLinkLocaleStatDo {
	return t.withDO(t.DO.Debug())
}

func (t tLinkLocaleStatDo) WithContext(ctx context.Context) ITLinkLocaleStatDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tLinkLocaleStatDo) ReadDB() ITLinkLocaleStatDo {
	return t.Clauses(dbresolver.Read)
}

func (t tLinkLocaleStatDo) WriteDB() ITLinkLocaleStatDo {
	return t.Clauses(dbresolver.Write)
}

func (t tLinkLocaleStatDo) Session(config *gorm.Session) ITLinkLocaleStatDo {
	return t.withDO(t.DO.Session(config))
}

func (t tLinkLocaleStatDo) Clauses(conds ...clause.Expression) ITLinkLocaleStatDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tLinkLocaleStatDo) Returning(value interface{}, columns ...string) ITLinkLocaleStatDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tLinkLocaleStatDo) Not(conds ...gen.Condition) ITLinkLocaleStatDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tLinkLocaleStatDo) Or(conds ...gen.Condition) ITLinkLocaleStatDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tLinkLocaleStatDo) Select(conds ...field.Expr) ITLinkLocaleStatDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tLinkLocaleStatDo) Where(conds ...gen.Condition) ITLinkLocaleStatDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tLinkLocaleStatDo) Order(conds ...field.Expr) ITLinkLocaleStatDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tLinkLocaleStatDo) Distinct(cols ...field.Expr) ITLinkLocaleStatDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tLinkLocaleStatDo) Omit(cols ...field.Expr) ITLinkLocaleStatDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tLinkLocaleStatDo) Join(table schema.Tabler, on ...field.Expr) ITLinkLocaleStatDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tLinkLocaleStatDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITLinkLocaleStatDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tLinkLocaleStatDo) RightJoin(table schema.Tabler, on ...field.Expr) ITLinkLocaleStatDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tLinkLocaleStatDo) Group(cols ...field.Expr) ITLinkLocaleStatDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tLinkLocaleStatDo) Having(conds ...gen.Condition) ITLinkLocaleStatDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tLinkLocaleStatDo) Limit(limit int) ITLinkLocaleStatDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tLinkLocaleStatDo) Offset(offset int) ITLinkLocaleStatDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tLinkLocaleStatDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITLinkLocaleStatDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tLinkLocaleStatDo) Unscoped() ITLinkLocaleStatDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tLinkLocaleStatDo) Create(values ...*model.TLinkLocaleStat) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tLinkLocaleStatDo) CreateInBatches(values []*model.TLinkLocaleStat, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tLinkLocaleStatDo) Save(values ...*model.TLinkLocaleStat) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tLinkLocaleStatDo) First() (*model.TLinkLocaleStat, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TLinkLocaleStat), nil
	}
}

func (t tLinkLocaleStatDo) Take() (*model.TLinkLocaleStat, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TLinkLocaleStat), nil
	}
}

func (t tLinkLocaleStatDo) Last() (*model.TLinkLocaleStat, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TLinkLocaleStat), nil
	}
}

func (t tLinkLocaleStatDo) Find() ([]*model.TLinkLocaleStat, error) {
	result, err := t.DO.Find()
	return result.([]*model.TLinkLocaleStat), err
}

func (t tLinkLocaleStatDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TLinkLocaleStat, err error) {
	buf := make([]*model.TLinkLocaleStat, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tLinkLocaleStatDo) FindInBatches(result *[]*model.TLinkLocaleStat, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tLinkLocaleStatDo) Attrs(attrs ...field.AssignExpr) ITLinkLocaleStatDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tLinkLocaleStatDo) Assign(attrs ...field.AssignExpr) ITLinkLocaleStatDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tLinkLocaleStatDo) Joins(fields ...field.RelationField) ITLinkLocaleStatDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tLinkLocaleStatDo) Preload(fields ...field.RelationField) ITLinkLocaleStatDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tLinkLocaleStatDo) FirstOrInit() (*model.TLinkLocaleStat, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TLinkLocaleStat), nil
	}
}

func (t tLinkLocaleStatDo) FirstOrCreate() (*model.TLinkLocaleStat, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TLinkLocaleStat), nil
	}
}

func (t tLinkLocaleStatDo) FindByPage(offset int, limit int) (result []*model.TLinkLocaleStat, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tLinkLocaleStatDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tLinkLocaleStatDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tLinkLocaleStatDo) Delete(models ...*model.TLinkLocaleStat) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tLinkLocaleStatDo) withDO(do gen.Dao) *tLinkLocaleStatDo {
	t.DO = *do.(*gen.DO)
	return t
}
